この講義は、 **Processing** （やCなど）がある程度扱える人を対象としています。  

このエディタは、変更を加えれば即座に反映されますが、 **セーブができません** 。  
本気でコードを書きたい場合、他のエディタで編集・保存し、このエディタに貼り付けることを推奨します。  

---

ここで解説するプログラマブルシェーダー（GLSL）の使い方は、 **本来の「シェーダ」の使い方ではありません** 。  
「元々、シェーダというものはどういう役割のものなのか？」  
という疑問に関しては、Googleなどで調べてください。  
一応、簡単に説明すれば、シェーダーは **3D空間上のポリゴンに陰影を付けるもの** です。  
そのため、このサイトで用いられるポリゴンは **正方形を作る二枚の三角形ポリゴン** のみです。

---

一番最初のシェーダーは、画面を緑色に潰すだけのシェーダーです。  
このシェーダーのゴールは **すべてのピクセルの色を緑に決定する** ことです。  

短いコードですが、順を追って説明していこうと思います。

---

```glsl
#ifdef GL_ES
precision mediump float;
#endif
```

は、簡単に言ってしまえば **おまじない** です。  
ある程度ちゃんと説明すれば、特定環境下において、浮動小数点の精度を変更するためのコードです。  
環境によっては高精度の浮動小数点に対応していないこともあるため、この３行は入れておいたほうが良いと思います。

---

次に、 `main` 関数内で、ピクセルの色を決定します。  
**`gl_FragColor` という変数に `vec4` 型で色を代入します** 。  

「なんだよ `vec4` 型って！！！」と思うあなた、大丈夫です。落ち着いてください。  
`vec4` は、 **４次元のfloat型のベクトル** です。  
**floatの値が４つ入る配列** と考えても大丈夫です。  
新しい `vec4` 型の変数を作るときは、右のコードのように、  
`vec4 color = vec4( 0.0, 1.0, 0.0, 1.0 );`  
とすれば良いです。  
また、 `color` という `vec4` 型の変数があるときに、
**`color.x = 1.0;`**  
とすれば、 `color` の１つめの値を `1.0` にすることができます。（ **試しに１行目と２行目の間に入れてみてください** ）  

さて、上の `color.x = 1.0;` を挿入した時に、画面が黄色に変わったはずです。  
カンの良い人はこれでわかったかもしれませんが、 **`gl_FragColor`** には、色の情報を **赤、緑、青、透明度** の順番で、 **0.0 から 1.0 の範囲** で `vec4` として 代入します。  
今まで Processing などでは、色を 0 から 255 の範囲で入れていたかもしれませんが、それを 255 で割るような間隔で大丈夫です。  
また、本サイトでは透明度には常に `1.0` を代入します。

---

- `void main()` はいつ実行されているの？  
`main` 関数は、すべてのピクセルごとに、一度のドローコール毎に実行される関数です。  
Processing で例えれば、 `void draw()` の中に `main();` を全ピクセル分書いてあるような感じです。  
